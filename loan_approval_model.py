# -*- coding: utf-8 -*-
"""Loan_Approval_Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oO60QD2HPN39B6IVmzF29RjKyMrd07Kl
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.metrics import accuracy_score
import pickle


file_path = "loan_approval_dataset.csv"
df = pd.read_csv(file_path)

print("Column names loaded by pandas:", df.columns.tolist())

df.rename(columns={
    ' no_of_dependents': 'no_of_dependents',
    ' education': 'education',
    ' self_employed': 'self_employed',
    ' income_annum': 'income_annum',
    ' loan_amount': 'loan_amount',
    ' loan_term': 'loan_term',
    ' cibil_score': 'cibil_score',
    ' residential_assets_value': 'residential_assets_value',
    ' commercial_assets_value': 'commercial_assets_value',
    ' luxury_assets_value': 'luxury_assets_value',
    ' bank_asset_value': 'bank_asset_value',
    ' loan_status': 'loan_status'
}, inplace=True)

# ... rest of your code

# Handle missing values
for col in ['no_of_dependents']:
    df[col].fillna(df[col].mode()[0], inplace=True)
for col in ['self_employed']:
    df[col].fillna(df[col].mode()[0], inplace=True)
for col in ['loan_amount', 'loan_term', 'cibil_score', 'income_annum',
            'residential_assets_value', 'commercial_assets_value',
            'luxury_assets_value', 'bank_asset_value']:
    df[col].fillna(df[col].median(), inplace=True)

# Encode categorical features
label_encoders = {}
for column in ['education', 'self_employed']:
    le = LabelEncoder()
    df[column] = le.fit_transform(df[column])
    label_encoders[column] = le

# Encode the target variable
le_loan_status = LabelEncoder()
df['loan_status'] = le_loan_status.fit_transform(df['loan_status'])
label_encoders['loan_status'] = le_loan_status

# Select features
features = ['no_of_dependents', 'education', 'self_employed', 'income_annum',
            'loan_amount', 'loan_term', 'cibil_score', 'residential_assets_value',
            'commercial_assets_value', 'luxury_assets_value', 'bank_asset_value']
X = df[features]
y = df['loan_status']

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

# Define the classifiers to compare
classifiers = {
    "Logistic Regression": LogisticRegression(random_state=42, solver='liblinear'),
    "Random Forest": RandomForestClassifier(n_estimators=100, random_state=42),
    "Gradient Boosting": GradientBoostingClassifier(n_estimators=100, random_state=42)
}

# Train and evaluate each classifier
model_performance = {}
for name, clf in classifiers.items():
    print(f"Training {name}...")
    clf.fit(X_train, y_train)
    y_pred = clf.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    model_performance[name] = accuracy
    print(f"{name} Accuracy: {accuracy:.4f}")

# Determine the best performing classifier (based on accuracy)
best_model_name = max(model_performance, key=model_performance.get)
best_model = classifiers[best_model_name]

print(f"\nBest performing model: {best_model_name} with accuracy: {model_performance[best_model_name]:.4f}")

# Train the final model (the best one) on the entire training dataset
print(f"\nTraining the final {best_model_name} model on the full training data...")
best_model.fit(X_train, y_train)

# Save the best trained model and label encoders
model_filename = 'loan_approval_model.pkl'
encoders_filename = 'loan_approval_encoders.pkl'

with open(model_filename, 'wb') as file:
    pickle.dump(best_model, file)

with open(encoders_filename, 'wb') as file:
    pickle.dump(label_encoders, file)

print(f"\nBest trained model saved as {model_filename}")
print(f"Label encoders saved as {encoders_filename}")
print("Features used for training:", features)
print("Education Encoding:", label_encoders['education'].classes_, "->", label_encoders['education'].transform(label_encoders['education'].classes_))
print("Self Employed Encoding:", label_encoders['self_employed'].classes_, "->", label_encoders['self_employed'].transform(label_encoders['self_employed'].classes_))
print("Loan Status Encoding:", label_encoders['loan_status'].classes_, "->", label_encoders['loan_status'].transform(label_encoders['loan_status'].classes_))